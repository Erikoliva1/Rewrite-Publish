<!DOCTYPE html>
<html lang="ne">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Rim Online</title>
  <link rel="icon" href="https://i.ibb.co/BKqH689b/logo.png" type="image/png" />
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      max-width: 850px;
      margin: auto;
      padding: 20px;
      background-color: #f2f2f2;
      color: #222;
    }

    .logo-container {
      text-align: center;
      margin-bottom: 5px;
    }

    .logo-container img {
      max-width: 100px;
      height: auto;
    }

    .rim-online-text {
      text-align: center;
      color: #ED2024;
      font-weight: bold;
      font-size: 1.2rem;
      margin-top: -5px;
      margin-bottom: 20px;
      letter-spacing: 1px;
    }

    .header-datetime {
      text-align: center;
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 15px;
      color: #444;
    }

    /* Original news input textarea */
    textarea#news { /* Specific selector for the input textarea */
      width: 100%;
      font-size: 16px;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #ccc;
      resize: vertical; /* Keep resize for the input textarea */
      min-height: 200px; /* Keep min-height for the input textarea */
      box-sizing: border-box;
      margin-top: 10px;
    }

    .input-group {
      margin-bottom: 15px;
    }

    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .input-group input[type="text"],
    .input-group select,
    .input-group input[type="file"] { /* Added file input */
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }

    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 10px;
      margin-bottom: 15px;
    }

    .checkbox-group div {
      display: flex;
      align-items: center;
    }

    .checkbox-group input[type="checkbox"] {
      margin-right: 8px;
      width: 18px;
      height: 18px;
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }

    .button-group button {
      flex: 1;
      padding: 12px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
    }

    .submit-btn {
      background-color: #007bff;
      color: white;
    }

    .submit-btn:hover {
      background-color: #0056b3;
    }

    .publish-btn {
      background-color: #ED2024;
      color: white;
    }

    .publish-btn:hover {
      background-color: #C7181B; /* Darker shade of red for hover effect */
    }

    .clear-btn {
      background-color: #6c757d;
      color: white;
    }

    .clear-btn:hover {
      background-color: #5a6268;
    }

    .copy-btn {
      background-color: #28a745;
      color: white;
    }

    .copy-btn:hover {
      background-color: #218838;
    }

    .paste-btn { /* NEW PASTE BUTTON STYLE */
      background-color: #17a2b8; /* Info blue color */
      color: white;
    }

    .paste-btn:hover {
      background-color: #138496; /* Darker blue */
    }

    /* NEW: Style for the image action buttons */
    .action-btn {
      flex: 1;
      padding: 12px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
      min-width: 150px; /* Ensure buttons don't get too small */
    }

    .action-btn:hover {
      opacity: 0.9; /* Simple hover effect */
    }


    /* UPDATED: Styles for the editable output textarea */
    textarea.output { /* Specific selector for the output textarea */
      margin-top: 20px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      border: 1px solid #ddd;
      white-space: pre-wrap; /* Preserve whitespace and line breaks */
      line-height: 1.6;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      width: 100%; /* Ensure it takes full width */
      box-sizing: border-box; /* Include padding in width */
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; /* Match body font */
      font-size: 16px; /* Match other textareas */
      color: #222; /* Default text color */
      overflow: hidden; /* Hide scrollbar initially */
      min-height: 100px; /* A smaller initial height for auto-grow */
      resize: none; /* REMOVED: Disable manual resizing */
    }

    .output.error-text {
      color: red;
    }

    .output.warning-text {
      color: orange;
    }

    /* Style for read-only state */
    .output[readonly] {
      background-color: #e9ecef; /* Lighter background to indicate non-editable */
      cursor: not-allowed;
    }

    /* Ensure publish button is full width if in its own group */
    .publish-button-group .publish-btn {
        flex: 1; /* Make it take full width if it's the only button in its group */
        width: 100%; /* Ensure it takes full width */
    }

    footer {
      text-align: center;
      margin-top: 40px;
      font-size: 14px;
      color: #333;
    }

    .creator-info {
      margin-bottom: 10px;
      font-size: 12px;
    }

    footer a {
      color: #007bff;
      text-decoration: underline;
    }

    /* Mobile responsive styles */
    @media screen and (max-width: 600px) {
      body {
        padding: 10px;
        font-size: 15px;
      }

      .rim-online-text {
        font-size: 1rem;
        margin-bottom: 20px;
      }

      .header-datetime {
        font-size: 13px;
        margin-bottom: 15px;
      }

      .button-group {
        flex-direction: column;
      }

      .button-group button {
        width: 100%;
        font-size: 15px;
      }

      textarea.output { /* Specific selector for the output textarea */
        font-size: 14px;
        padding: 15px;
        min-height: 100px; /* Adjusted for smaller screens */
      }

      footer {
        font-size: 12px;
      }

      .creator-info {
        font-size: 11px;
      }

      textarea#news { /* Specific selector for the input textarea */
        font-size: 15px;
        padding: 10px;
        min-height: 150px;
      }

      /* Adjustments for mobile responsiveness for the new publish button group */
      .publish-button-group {
        flex-direction: column;
      }
      .publish-button-group .publish-btn {
        width: 100%;
        font-size: 15px;
      }

      /* NEW: Mobile adjustments for image action buttons */
      .button-group .action-btn {
        width: 100%;
        min-width: unset; /* Remove min-width on mobile */
      }
    }
  </style>
</head>
<body>

  <div class="logo-container">
    <a href="https://therimonline.com/" target="_blank">
      <img src="https://i.ibb.co/BKqH689b/logo.png" alt="The Rim Online Logo" />
    </a>
    <div class="rim-online-text">THE RIM ONLINE</div>

    <!-- Buy Me a Coffee Button -->
    <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js"
            data-name="bmc-button"
            data-slug="prabhatyadav"
            data-color="#FFDD00"
            data-emoji=""
            data-font="Cookie"
            data-text="Buy me a coffee"
            data-outline-color="#000000"
            data-font-color="#000000"
            data-coffee-color="#ffffff"></script>

    <div class="header-datetime" id="nepaliDateTime">लोड हुँदैछ...</div>
  </div>

  <textarea id="news" placeholder="Paste your news here..."></textarea>

  <div class="input-group">
    <label for="api-select">Select API:</label>
    <select id="api-select">
      <option value="azure_gpt41">Azure GPT-4.1</option>
      <option value="azure_gpt41_nano">Azure GPT-4.1 Nano</option>
      <option value="openrouter_gpt41_nano">OpenRouter GPT-4.1 Nano</option>
      <option value="openrouter_deepseek">OpenRouter DeepSeek</option>
      <option value="azure_gpt41_mini">Azure GPT-4.1 Mini</option>
      <option value="azure_grok">Azure Grok</option>
      <option value="openrouter_gpt35">OpenRouter GPT-3.5</option>
      <option value="openrouter_gemma">OpenRouter Gemma</option>
      <option value="openrouter_claude3">OpenRouter Claude-3</option>
      <!-- NEW PUTER.COM OPTIONS -->
      <option value="puter_claude_sonnet_4">Puter Claude Sonnet 4</option>
      <option value="puter_grok_beta">Puter Grok Beta</option>
      <option value="puter_gemini_2_0_flash">Puter Gemini 2.0 Flash</option>
      <option value="puter_gemini_1_5_flash">Puter Gemini 1.5 Flash</option>
      <option value="puter_openai_o3_mini">Puter OpenAI o3-mini</option>
      <option value="puter_deepseek_chat">Puter DeepSeek Chat</option>
      <option value="puter_deepseek_reasoner">Puter DeepSeek Reasoner</option>
    </select>
  </div>

  <div class="input-group">
    <label for="featuredImageFile">Featured Image (Local File - Optional):</label>
    <input type="file" id="featuredImageFile" accept="image/*">
    <p id="imageUploadStatus" style="font-size: 0.9em; margin-top: 5px;"></p>
  </div>

  <div class="button-group">
    <button class="action-btn" onclick="applyWatermarkAndPrepareDownload()" style="background-color: #007bff;">Apply Watermark</button>
    <button class="action-btn" onclick="downloadWatermarkedImage()" style="background-color: #28a745;">Download Watermarked</button>
    <button class="action-btn" onclick="uploadPreparedImage()" style="background-color: #ffc107; color: #333;">Upload to WordPress</button>
  </div>

  <div class="input-group">
    <label>Categories:</label>
    <div class="checkbox-group">
      <div><input type="checkbox" id="cat_mukhya" value="मुख्य समाचार"><label for="cat_mukhya">मुख्य समाचार</label></div>
      <div><input type="checkbox" id="cat_samachar" value="समाचार"><label for="cat_samachar">समाचार</label></div>
      <div><input type="checkbox" id="cat_desh" value="देश"><label for="cat_desh">देश</label></div>
      <div><input type="checkbox" id="cat_rajniti" value="राजनिति"><label for="cat_rajniti">राजनिति</label></div>
      <div><input type="checkbox" id="cat_artha" value="अर्थ"><label for="cat_artha">अर्थ</label></div>
      <div><input type="checkbox" id="cat_khelkud" value="खेलकुद"><label for="cat_khelkud">खेलकुद</label></div>
      <div><input type="checkbox" id="cat_feature" value="फिचर"><label for="cat_feature">फिचर</label></div>
      <div><input type="checkbox" id="cat_manoranjan" value="मनोरञ्जन"><label for="cat_manoranjan">मनोरञ्जन</label></div>
      <div><input type="checkbox" id="cat_vichar" value="विचार"><label for="cat_vichar">विचार</label></div>
      <div><input type="checkbox" id="cat_videsh" value="विदेश"><label for="cat_videsh">विदेश</label></div>
      <div><input type="checkbox" id="cat_swasthya" value="स्वास्थ्य/जीवनशैली"><label for="cat_swasthya">स्वास्थ्य/जीवनशैली</label></div>
      <div><input type="checkbox" id="cat_Banner" value="Banner"><label for="cat_Banner">Banner</label></div>
    </div>
  </div>

  <div class="button-group">
    <button class="submit-btn" onclick="rewriteNews()">Submit</button>
    <button class="clear-btn" onclick="clearFields()">Clear</button>
    <button class="copy-btn" onclick="copyResult()">Copy Result</button>
    <button class="paste-btn" onclick="pasteFromClipboard()">Paste</button>
  </div>

  <!-- UPDATED: Changed from div to textarea for editing -->
  <textarea class="output" id="resultBox" placeholder="Rewritten news will appear here..." readonly></textarea>

  <div class="button-group publish-button-group" style="margin-top: 15px;"> <!-- New button group for publish -->
    <button class="publish-btn" onclick="publishNews()">Publish</button>
  </div>

  <footer>
    <div class="creator-info">
      Created by <a href="https://www.facebook.com/prabhatyadav99" target="_blank">Prabhat Yadav</a> <br />
      <a href="mailto:prabhatyadav2003@gmail.com">prabhatyadav2003@gmail.com</a> |
      <a href="tel:+977 9705858058">+977 9705858058</a>
    </div>
    &copy; The Rim Online — All Rights Reserved
  </footer>

  <!-- Puter.com SDK Script -->
  <script src="https://js.puter.com/v2/"></script>

  <script>
    let featuredImageId = null; // This will store the ID from WordPress
    let lastWatermarkedBlob = null; // Stores the watermarked blob for debugging and upload
    let originalSelectedFile = null; // Stores the original file selected by the user

    // --- Watermark Image Loading ---
    let watermarkImage = new Image();
    let watermarkLoaded = false;

    // Load watermark image
    watermarkImage.onload = () => {
        console.log("Watermark: watermark.png loaded successfully.");
        watermarkLoaded = true;
        document.getElementById('imageUploadStatus').textContent = "Watermark loaded. Select an image to apply watermark.";
        document.getElementById('imageUploadStatus').style.color = 'green';
    };

    watermarkImage.onerror = () => {
        console.error("Watermark: Failed to load watermark.png. Watermarking will be skipped.");
        watermarkLoaded = false;
        document.getElementById('imageUploadStatus').textContent = "Error: Watermark image failed to load. Image processing will proceed without watermarking.";
        document.getElementById('imageUploadStatus').style.color = 'red';
    };

    // Set source after setting up event handlers
    watermarkImage.src = "/static/watermark.png";

    // Function to auto-resize textarea
    function autoResizeTextarea(textarea) {
      textarea.style.height = 'auto'; // Reset height to recalculate
      textarea.style.height = (textarea.scrollHeight) + 'px'; // Set height to scroll height
    }

    // --- New Function: Apply Watermark to Image ---
    function applyWatermark(file, watermarkImg) {
        console.log("Watermark: Starting applyWatermark for file:", file.name, "type:", file.type);
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');

                        // Set canvas dimensions to match the original image
                        canvas.width = img.width;
                        canvas.height = img.height;
                        console.log("Watermark: Original image loaded into canvas. Dimensions:", img.width, "x", img.height);

                        // Draw the original image
                        ctx.drawImage(img, 0, 0);

                        // --- Watermark Drawing Logic ---
                        const watermarkScale = 0.2; // Watermark will be 20% of the main image's width
                        const padding = img.width * 0.02; // 2% padding from edges

                        let watermarkDrawWidth = img.width * watermarkScale;
                        let watermarkDrawHeight = (watermarkImg.naturalHeight / watermarkImg.naturalWidth) * watermarkDrawWidth;

                        // Ensure watermark doesn't exceed image height if it's very tall
                        if (watermarkDrawHeight > img.height * 0.8) { // Limit to 80% of image height
                            watermarkDrawHeight = img.height * 0.8;
                            watermarkDrawWidth = (watermarkImg.naturalWidth / watermarkImg.naturalHeight) * watermarkDrawHeight;
                        }
                        console.log("Watermark: Calculated watermark draw dimensions:", watermarkDrawWidth, "x", watermarkDrawHeight);

                        const x = img.width - watermarkDrawWidth - padding;
                        const y = img.height - watermarkDrawHeight - padding;
                        console.log("Watermark: Calculated watermark position (x,y):", x, y);

                        ctx.globalAlpha = 0.7; // Set watermark opacity (e.g., 70%)
                        ctx.drawImage(watermarkImg, x, y, watermarkDrawWidth, watermarkDrawHeight);
                        ctx.globalAlpha = 1.0; // Reset alpha for subsequent drawings
                        console.log("Watermark: Watermark drawn on canvas.");

                        // Convert canvas to Blob
                        // Use original file type, 1.0 quality for JPEG/WebP to preserve quality
                        // Ensure file.type is a valid MIME type for toBlob
                        const outputMimeType = file.type && file.type.startsWith('image/') ? file.type : 'image/jpeg';
                        console.log("Watermark: Attempting to convert canvas to blob with type:", outputMimeType, "and quality: 1.0");

                        canvas.toBlob((blob) => {
                            if (blob) {
                                console.log("Watermark: Watermarked blob created successfully. Size:", blob.size, "Type:", blob.type);
                                // Tag the blob so we can identify it as watermarked
                                blob._isWatermarked = true;
                                resolve(blob);
                            } else {
                                console.error("Watermark: Failed to create blob from canvas (blob is null).");
                                resolve(null);
                            }
                        }, outputMimeType, 1.0); // CHANGED: Quality from 0.9 to 1.0
                    } catch (error) {
                        console.error("Watermark: Error in watermarking canvas process:", error);
                        resolve(null);
                    }
                };
                img.onerror = (error) => {
                    console.error("Watermark: Failed to load user's image into Image object for watermarking:", error);
                    resolve(null);
                };
                img.src = event.target.result;
            };
            reader.onerror = (error) => {
                console.error("Watermark: Failed to read user's file with FileReader:", error);
                resolve(null);
            };
            reader.readAsDataURL(file);
        });
    }

    // --- NEW: Store the selected file ---
    document.getElementById('featuredImageFile').addEventListener('change', function(event) {
        originalSelectedFile = event.target.files[0];
        const statusDiv = document.getElementById('imageUploadStatus');
        if (originalSelectedFile) {
            statusDiv.textContent = `File selected: ${originalSelectedFile.name}. Click 'Apply Watermark'.`;
            statusDiv.style.color = 'blue';
            lastWatermarkedBlob = null; // Clear any previously prepared blob
            featuredImageId = null; // Clear any previous ID
        } else {
            statusDiv.textContent = "No file selected.";
            statusDiv.style.color = 'red';
        }
    });

    // --- NEW: Function to apply watermark and prepare for download/upload ---
    async function applyWatermarkAndPrepareDownload() {
        const statusDiv = document.getElementById('imageUploadStatus');

        if (!originalSelectedFile) {
            statusDiv.style.color = 'red';
            statusDiv.textContent = "Please select an image file first.";
            console.log("Watermark Apply: No file selected.");
            return;
        }

        if (!watermarkLoaded || !watermarkImage.complete || watermarkImage.naturalWidth === 0) {
            statusDiv.style.color = 'orange';
            statusDiv.textContent = "Watermark image not loaded. Cannot apply watermark.";
            console.log("Watermark Apply: Watermark image not ready.");
            return;
        }

        statusDiv.style.color = 'orange';
        statusDiv.textContent = "Applying watermark... Please wait.";
        console.log("Watermark Apply: Starting watermark application for:", originalSelectedFile.name);

        try {
            const watermarkedBlob = await applyWatermark(originalSelectedFile, watermarkImage);

            if (watermarkedBlob && watermarkedBlob.size > 0) {
                lastWatermarkedBlob = watermarkedBlob; // Store the watermarked blob
                statusDiv.style.color = 'green';
                statusDiv.textContent = "Watermark applied successfully! Ready for Download or Upload.";
                console.log("Watermark Apply: Watermark applied and blob stored. Size:", watermarkedBlob.size, "Type:", watermarkedBlob.type, "Is Watermarked Tag:", watermarkedBlob._isWatermarked);
            } else {
                statusDiv.style.color = 'red';
                statusDiv.textContent = "Failed to apply watermark. Please try again or upload original.";
                console.error("Watermark Apply: Watermarking failed or returned empty blob.");
                lastWatermarkedBlob = null; // Ensure it's null if failed
            }
        } catch (err) {
            console.error("Watermark Apply: Error during watermarking:", err);
            statusDiv.style.color = 'red';
            statusDiv.textContent = `Error applying watermark: ${err.message}.`;
            lastWatermarkedBlob = null; // Ensure it's null if failed
        }
    }

    // --- Existing: Download Watermarked Image (now uses lastWatermarkedBlob) ---
    function downloadWatermarkedImage() {
        if (lastWatermarkedBlob) {
            const url = URL.createObjectURL(lastWatermarkedBlob);
            const a = document.createElement('a');
            a.href = url;
            // Use the original file name for the download, but indicate it's watermarked
            const originalFileName = originalSelectedFile ? originalSelectedFile.name : 'image';
            const fileNameParts = originalFileName.split('.');
            const extension = fileNameParts.pop();
            const baseName = fileNameParts.join('.');
            a.download = `${baseName}_watermarked.${extension || 'jpg'}`;

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert("Watermarked image downloaded for inspection. Check your downloads folder.");
            console.log("Debug: Downloaded watermarked blob for inspection.");
        } else {
            alert("No watermarked image available to download. Please select an image and click 'Apply Watermark' first.");
            console.log("Debug: No watermarked blob available for download.");
        }
    }

    // --- NEW: Function to upload the prepared (watermarked) image ---
    async function uploadPreparedImage() {
      const statusDiv = document.getElementById('imageUploadStatus');

      if (!lastWatermarkedBlob) {
        statusDiv.style.color = 'red';
        statusDiv.textContent = "No watermarked image prepared. Please select an image and click 'Apply Watermark' first.";
        console.log("Upload: No watermarked blob available for upload.");
        return;
      }

      if (!originalSelectedFile) {
        statusDiv.style.color = 'red';
        statusDiv.textContent = "Original file information missing. Please re-select the image.";
        console.log("Upload: Original file info missing.");
        return;
      }

      statusDiv.style.color = 'orange';
      statusDiv.textContent = "Uploading watermarked image to WordPress... Please wait.";
      console.log("Upload: Starting upload process for watermarked blob (size:", lastWatermarkedBlob.size, "type:", lastWatermarkedBlob.type, "Is Watermarked Tag:", lastWatermarkedBlob._isWatermarked, ").");

      // --- NEW DEBUGGING: Read blob content and log hash ---
      const readerForHash = new FileReader();
      readerForHash.onload = function(e) {
          const arrayBuffer = e.target.result;
          const byteArray = new Uint8Array(arrayBuffer);
          let hash = 0;
          for (let i = 0; i < Math.min(byteArray.length, 1024); i++) { // Hash first 1KB
              hash = ((hash << 5) - hash) + byteArray[i];
              hash |= 0; // Convert to 32bit integer
          }
          console.log("Client-side watermarked blob SHA-like hash (first 1KB):", hash.toString(16));
      };
      readerForHash.readAsArrayBuffer(lastWatermarkedBlob);
      // --- END NEW DEBUGGING ---

      const formData = new FormData();
      // IMPORTANT: Use the original file name for the blob, so WordPress gets the correct extension
      formData.append('file', lastWatermarkedBlob, originalSelectedFile.name);
      console.log("Uploading watermarked blob:", {
          originalSize: originalSelectedFile.size,
          watermarkedSize: lastWatermarkedBlob.size,
          fileName: originalSelectedFile.name,
          blobType: lastWatermarkedBlob.type,
          sizeDifference: lastWatermarkedBlob.size - originalSelectedFile.size,
          isWatermarked: lastWatermarkedBlob._isWatermarked || 'not tagged'
      });
      statusDiv.textContent = "Uploading watermarked image...";
      console.log("Upload: FormData prepared with watermarked blob and original filename. Sending to backend proxy.");

      try {
        // Send the file to your Python backend's proxy endpoint
        const response = await fetch('/upload-image', {
          method: 'POST',
          body: formData,
        });

        if (response.ok) {
          const data = await response.json();
          featuredImageId = data.id; // Store the WordPress media ID
          statusDiv.style.color = 'green';
          statusDiv.textContent = `Image uploaded successfully! Media ID: ${featuredImageId}`;
          console.log("Upload: Backend proxy successful. WordPress Media ID:", featuredImageId);
        } else {
          const errorData = await response.json();
          statusDiv.style.color = 'red';
          statusDiv.textContent = `Error uploading image: ${errorData.detail || errorData.message || 'Unknown error'}`;
          featuredImageId = null; // Reset ID on failure
          console.error("Upload: Backend proxy failed. Status:", response.status, "Error:", errorData);
        }
      } catch (err) {
        console.error("Upload: Error during image upload fetch request:", err);
        statusDiv.style.color = 'red';
        statusDiv.textContent = `Error uploading image: ${err.message}`;
        featuredImageId = null; // Reset ID on failure
      }
    }

    async function rewriteNews() {
      const news = document.getElementById("news").value.trim();
      const api = document.getElementById("api-select").value;
      const resultBox = document.getElementById("resultBox");

      // Clear previous status/error classes and ensure it's read-only for messages
      resultBox.classList.remove('error-text', 'warning-text');
      resultBox.style.color = ''; // Reset inline color
      resultBox.setAttribute('readonly', 'true'); // Make it read-only for messages

      if (!news) {
        resultBox.value = "Please paste a news."; // Use .value for textarea
        resultBox.classList.add('error-text'); // Add error class
        autoResizeTextarea(resultBox); // Auto-resize for the message
        return;
      }

      resultBox.value = "Please wait... Processing your news..."; // Use .value for textarea
      resultBox.style.color = 'initial'; // Ensure default color for processing message
      autoResizeTextarea(resultBox); // Auto-resize for the message

      // Define the system prompt for the AI models
      const systemPrompt = "You are a professional Nepali news editor. Generate a short and relevant headline, then rewrite the article in totally new style and structure by not losing originality using standard journalistic Nepali. Result must be in the same paragraph count. No need to mention Explanation of changes, Key Changes & style notes just focus on best rewritting result in nepali.";
      const userPrompt = `Original news:\n${news.replace(/\n\n/g, "\n\n[PARAGRAPH_BREAK]\n\n")}\n\nRewritten news:`;

      // List of Puter.com API options
      const puterApiModels = [
        "puter_claude_sonnet_4",
        "puter_grok_beta",
        "puter_gemini_2_0_flash",
        "puter_gemini_1_5_flash",
        "puter_openai_o3_mini",
        "puter_deepseek_chat",
        "puter_deepseek_reasoner"
      ];

      // --- Puter.com API Calls (Client-Side) ---
      if (puterApiModels.includes(api)) {
        try {
          // Ensure puter.ai is available
          if (typeof puter === 'undefined' || typeof puter.ai === 'undefined' || typeof puter.ai.chat === 'undefined') {
            resultBox.value = "Puter.com SDK not loaded or initialized. Please check your internet connection or the script tag.";
            resultBox.classList.add('error-text');
            autoResizeTextarea(resultBox);
            return;
          }

          let modelName;
          switch (api) {
            case "puter_claude_sonnet_4": modelName = "claude-sonnet-4"; break;
            case "puter_grok_beta": modelName = "grok-beta"; break;
            case "puter_gemini_2_0_flash": modelName = "gemini-2.0-flash"; break;
            case "puter_gemini_1_5_flash": modelName = "gemini-1.5-flash"; break;
            case "puter_openai_o3_mini": modelName = "o3-mini"; break;
            case "puter_deepseek_chat": modelName = "deepseek-chat"; break;
            case "puter_deepseek_reasoner": modelName = "deepseek-reasoner"; break;
            default: modelName = ""; // Should not happen due to includes check
          }

          resultBox.value = `Calling Puter.com ${modelName}...`;
          autoResizeTextarea(resultBox);

          let fullResponse = "";
          const chat_resp = await puter.ai.chat(userPrompt, {
            model: modelName,
            stream: true,
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ]
          });

          for await (const part of chat_resp) {
            if (part && part.text) {
              fullResponse += part.text;
              resultBox.value = fullResponse.replace(/\[PARAGRAPH_BREAK\]/g, "\n");
              autoResizeTextarea(resultBox); // Update as content streams
            }
          }

          if (fullResponse) {
            resultBox.value = fullResponse.replace(/\[PARAGRAPH_BREAK\]/g, "\n");
            resultBox.removeAttribute('readonly');
            autoResizeTextarea(resultBox);
          } else {
            resultBox.value = `Error: No response from Puter.com ${modelName}.`;
            resultBox.classList.add('error-text');
            autoResizeTextarea(resultBox);
          }

        } catch (err) {
          console.error("Error calling Puter.com API:", err);
          resultBox.value = `Error calling Puter.com API: ${err.message || 'Unknown error'}.`;
          resultBox.classList.add('error-text');
          autoResizeTextarea(resultBox);
        }
        return; // Exit function after handling Puter.com API
      }

      // --- Existing Backend API Calls ---
      try {
        const response = await fetch("/rewrite", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ news, api })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.rewritten_news) {
            const formattedNews = data.rewritten_news.replace(/\[PARAGRAPH_BREAK\]/g, "\n");
            resultBox.value = formattedNews; // Use .value for textarea
            resultBox.removeAttribute('readonly'); // Make it editable after successful rewrite
            autoResizeTextarea(resultBox); // Auto-resize for the rewritten content
          } else {
            resultBox.value = `Error: ${data.error || 'Unknown error occurred'}`; // Use .value for textarea
            resultBox.classList.add('error-text'); // Add error class
            autoResizeTextarea(resultBox); // Auto-resize for the error message
          }
        } else {
          const errorData = await response.json();
          if (response.status === 429) {
            resultBox.value = `Rate Limit: ${errorData.detail}`; // Use .value for textarea
            resultBox.classList.add('warning-text'); // Add warning class
          } else {
            resultBox.value = `Error: ${errorData.detail || 'Unknown error occurred'}`; // Use .value for textarea
            resultBox.classList.add('error-text'); // Add error class
          }
          autoResizeTextarea(resultBox); // Auto-resize for the error/warning message
        }
      } catch (err) {
        console.error(err);
        resultBox.value = `Error: ${err.message}`; // Use .value for textarea
        resultBox.classList.add('error-text'); // Add error class
        autoResizeTextarea(resultBox); // Auto-resize for the error message
      }
    }

    function clearFields() {
      document.getElementById("news").value = "";
      const resultBox = document.getElementById("resultBox");
      resultBox.value = ""; // Use .value for textarea
      resultBox.classList.remove('error-text', 'warning-text'); // Clear status classes
      resultBox.style.color = ''; // Clear inline color
      resultBox.setAttribute('readonly', 'true'); // Ensure it's read-only when cleared
      autoResizeTextarea(resultBox); // Auto-resize to its minimum height

      // Clear image related fields and states
      document.getElementById("featuredImageFile").value = ""; // Clear file input
      originalSelectedFile = null; // Clear original file
      lastWatermarkedBlob = null; // Clear the prepared blob
      featuredImageId = null; // Clear the WordPress ID

      // Reset status message based on watermark load status
      const statusDiv = document.getElementById("imageUploadStatus");
      if (watermarkLoaded && watermarkImage.complete && watermarkImage.naturalWidth > 0) {
          statusDiv.textContent = "Watermark loaded. Select an image to apply watermark.";
          statusDiv.style.color = 'green';
      } else {
          statusDiv.textContent = "Error: Watermark image failed to load. Image processing will proceed without watermarking.";
          statusDiv.style.color = 'red';
      }

      document.getElementById("api-select").value = "azure_gpt41";
      document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
    }

    function copyResult() {
      const resultText = document.getElementById("resultBox").value; // Use .value for textarea
      if (!resultText) return alert("No result to copy.");
      navigator.clipboard.writeText(resultText)
        .then(() => alert("Result copied to clipboard!"))
        .catch(err => alert("Copy failed."));
    }

    async function pasteFromClipboard() {
      const newsInput = document.getElementById("news");
      try {
        const text = await navigator.clipboard.readText();
        if (text) {
          newsInput.value = text;
          alert("Content pasted from clipboard!");
        } else {
          alert("Clipboard is empty or does not contain text.");
        }
      } catch (err) {
        console.error("Failed to read clipboard contents: ", err);
        alert("Failed to paste from clipboard. Please ensure you grant clipboard access to this site.");
      }
    }

    async function publishNews() {
      const resultBox = document.getElementById("resultBox");
      const rewrittenNews = resultBox.value.trim(); // Use .value for textarea

      // Clear previous status/error classes and ensure it's read-only for messages
      resultBox.classList.remove('error-text', 'warning-text');
      resultBox.style.color = ''; // Reset inline color
      resultBox.setAttribute('readonly', 'true'); // Make it read-only for messages

      const selectedCategories = Array.from(document.querySelectorAll('input[id^="cat_"]:checked'))
                                    .map(cb => cb.value);
      const selectedTags = Array.from(document.querySelectorAll('input[id^="tag_"]:checked'))
                                .map(cb => cb.value);

      if (!rewrittenNews) {
        resultBox.value = "Please rewrite the news first."; // Use .value for textarea
        resultBox.classList.add('error-text'); // Add error class
        autoResizeTextarea(resultBox); // Auto-resize for the message
        return;
      }

      resultBox.value = "Please wait... Publishing your news..."; // Use .value for textarea
      resultBox.style.color = 'initial'; // Ensure default color for publishing message
      autoResizeTextarea(resultBox); // Auto-resize for the message

      // REMOVED: The prefixesToRemove logic is no longer needed here
      let cleanedNews = rewrittenNews; // Use the user-edited content directly

      try {
        const response = await fetch("/publish", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            news: cleanedNews,
            featured_image_id: featuredImageId, // Use the stored media ID
            categories: selectedCategories,
            tags: selectedTags
          })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.message) {
            resultBox.value = `Result:\n\n${data.message}`; // Use .value for textarea
          } else {
            resultBox.value = `Error: ${data.error || 'Unknown error occurred'}`; // Use .value for textarea
            resultBox.classList.add('error-text'); // Add error class
          }
          autoResizeTextarea(resultBox); // Auto-resize for the final message
        } else {
          const errorData = await response.json();
          resultBox.value = `Error: ${errorData.detail || 'Unknown error occurred'}`; // Use .value for textarea
          resultBox.classList.add('error-text'); // Add error class
          autoResizeTextarea(resultBox); // Auto-resize for the error message
        }
      } catch (err) {
        console.error(err);
        resultBox.value = `Error: ${err.message}`; // Use .value for textarea
        resultBox.classList.add('error-text'); // Add error class
        autoResizeTextarea(resultBox); // Auto-resize for the error message
      }
    }

    function toNepaliDigits(str) {
      const nd = ['०','१','२','३','४','५','६','७','८','९'];
      return str.replace(/\d/g, d => nd[d]);
    }

    const bsMonthNames = ['बैशाख','जेठ','असार','साउन','भदौ','असोज','कार्तिक','मंसिर','पुष','माघ','फाल्गुन','चैत्र'];
    const bsDayNames = ['आइतबार','सोमबार','मंगलबार','बुधबार','बिहिबार','शुक्रबार','शनिबार'];

    const bsData = [
      [2000, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
      [2082, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
      [2090, 31, 31, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31]
    ];

    function adToBs(adDate) {
      const known = new Date('2025-07-30'); // AD date corresponding to baseBS
      const baseBS = { year: 2082, month: 4, day: 14 }; // BS date for known AD date

      const diffDays = Math.floor((adDate - known) / (1000 * 60 * 60 * 24));
      let bsY = baseBS.year, bsM = baseBS.month, bsD = baseBS.day + diffDays;

      const getMonthLength = (y, m) => {
        let row = bsData.find(d => d[0] === y);
        if (!row) {
            // Fallback to 2082 data if exact year not found.
            // This will introduce inaccuracies for years far from 2082, 2000, 2090.
            row = bsData.find(d => d[0] === 2082);
            if (!row) {
                console.warn("BS Data for 2082 not found, using generic 30-day month.");
                return 30; // Absolute fallback if 2082 data is also missing (shouldn't happen)
            }
        }
        return row[m]; // m is 1-indexed for months in bsData
      };

      // Loop to adjust month and year
      while (bsD > getMonthLength(bsY, bsM)) {
        bsD -= getMonthLength(bsY, bsM);
        bsM++;
        if (bsM > 12) {
          bsM = 1;
          bsY++;
        }
      }

      while (bsD <= 0) {
        bsM--;
        if (bsM < 1) {
          bsM = 12;
          bsY--;
        }
        bsD += getMonthLength(bsY, bsM);
      }

      return { year: bsY, month: bsM, day: bsD };
    }

    function getNepaliDateTime() {
      const now = new Date();
      const utc = now.getTime() + now.getTimezoneOffset() * 60000;
      const nepalTime = new Date(utc + 5.75 * 3600000);
      const bs = adToBs(nepalTime);

      const bsDay = bsDayNames[nepalTime.getDay()];
      const bsYear = bs.year;
      const bsMonth = bsMonthNames[bs.month - 1];
      const bsDate = bs.day;

      let hours = nepalTime.getHours();
      let minutes = nepalTime.getMinutes();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12;
      hours = hours ? hours : 12;
      const formattedTime = `${toNepaliDigits(hours.toString())}:${toNepaliDigits(minutes.toString().padStart(2, '0'))} ${ampm}`;

      return `${toNepaliDigits(bsYear.toString())} ${bsMonth} ${toNepaliDigits(bsDate.toString())}, ${bsDay}, समय: ${formattedTime}`;
    }

    function loadNepaliDateTime() {
      const el = document.getElementById('nepaliDateTime');
      try {
        el.textContent = getNepaliDateTime();
      } catch (e) {
        console.error("Error loading Nepali date:", e);
        el.textContent = "तिथि प्रदर्शन गर्न असमर्थ"; // "Unable to display date"
      }
    }

    // Initial calls on page load
    loadNepaliDateTime();
    setInterval(loadNepaliDateTime, 60000);

    // Auto-resize the resultBox on input (user typing)
    document.addEventListener('DOMContentLoaded', () => {
      const resultBox = document.getElementById('resultBox');
      resultBox.addEventListener('input', () => autoResizeTextarea(resultBox));
      // Initial resize in case there's placeholder text or default content
      autoResizeTextarea(resultBox);
    });
  </script>

</body>
</html>
